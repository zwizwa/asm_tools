-- A simple wrapper to expose file generator rules as Makefile rules.

-- Back story:
--
-- 1) For embedded software with Linux build systems, I've
-- standardized on GNU Make.  Most people with a systems programming
-- background know this.  Keeping Makefiles simple then ensures the
-- build system is not obvuscated too much.
--
-- 2) Custom code generators seem to be plentiful in embedded software
-- projects.  I'm standardizing on Haskell.  Now, most people with a
-- systems programming background do not know Haskell, so one avenue
-- is to still use Makefiles to specify how each individual file was
-- generated.
--
-- The practical approach is to use a 3-step dependency:
--
-- - Cabal or some other Haskell build tool is used to build the
--   generator.  It seems convenient to use only a single or a small
--   number of generator binaries per project to keep compilation
--   times at a minimum.
--
-- - The code in this module performs dispatch to generate files,
--   while also producing a Makefile fragmenet that can be included in
--   the main Makefile.
--
-- - Each file is then generated by make, through multiple invocations
--   of the generator.
--
-- See f_soc.hs and the main Makefile for an example of how this all
-- fits together.  One way to look at it is that the "targets" table
-- in f_soc.hs is essentially a Makefile, but instead of calling shell
-- scripts, it calls Haskell code to write the files.


module Language.MakeDeps where

import Data.Maybe
import Data.List
import System.Environment
import System.Argv0
import qualified Filesystem.Path.CurrentOS

-- a rule contains products and deps
type Rule = ([String],[String])
type Gen  = (Rule, Rule -> IO ())

-- Generic routine
build' :: String -> String -> [String] -> [Gen] -> IO ()
build' files_var executable args targets =
  case args  of
    [] -> putStr $ makefile
    prods -> fromJust $ lookup (toKey prods) rules
  where
    toKey prods = list $ sort prods
    
    list = intercalate " "
    allprods = map (fst . fst) targets
    makefile =
      "# -*- makefile -*-\n" ++
      "# Generated by Language.MakeDeps.build\n" ++
      files_var ++ " := " ++ (list $ concat allprods) ++ "\n" ++
      (concat $ map (dep . fst) targets)
    dep (prods, deps) =
      -- FIXME: quoting.  Filenames cannot contain spaces.
      "\n" ++ list prods ++ ": " ++ list (executable:deps) ++ "\n" ++
      "\t" ++ executable ++ " " ++ list prods ++ "\n"

    rules = map (\(pd@(prods, deps), build) -> (toKey prods, build pd)) targets

build :: String -> [Gen] -> IO ()
build files_var targets = do
  -- Note: use argv[0] instead of getProgName.  This allows the
  -- makefile to be generated with the proper invocation of the
  -- executable.
  argv0 <- getArgv0
  let argv0' = Filesystem.Path.CurrentOS.encodeString argv0
  args  <- getArgs
  build' files_var argv0' args targets
