-- (DISC) Expose hs file generator rules as Makefile rules.

-- Back story:
--
-- 1) For embedded software with Linux build systems, I've
-- standardized on GNU Make.  People with a Linux systems programming
-- background know how to read a Makefile.  Keeping Makefiles simple
-- then ensures the build system is not obvuscated too much.
--
-- 2) Custom code generators seem to be plentiful in embedded software
-- projects.  I'm standardizing on Haskell to implement these.  Now,
-- most people with a systems programming background do not know
-- Haskell, so one avenue to at least allow "cargo cult mods" is to
-- still use Makefiles to specify how each individual file was
-- generated.
--
-- The practical approach is to use a 3-step dependency:
--
-- - Cabal or some other Haskell build tool is used to build the
--   generator executable.  It seems convenient to use only a single
--   or a small number of generator binaries per project to avoid
--   boilerplate code (generator .hs file, cabal file entry, Makefile
--   entre), and to keep compilation times and build products small.
--
-- - The code in this module performs dispatch to Haskell code
--   generator functions, while also producing a Makefile fragmenet
--   that can be included in the main Makefile.
--
-- - Each file can then be generated by make through an invocations of
--   the generator executable.  This still allows fast incremental
--   rebuilds if the generator itself does not change, i.e. only its
--   input files change.
--
-- See f_soc.hs and the main Makefile for an example of how this all
-- fits together.  One way to look at it is that the "targets" table
-- in f_soc.hs is essentially a Makefile, but instead of calling shell
-- scripts, it calls Haskell code to write the files.


module Data.AsmTools.Make where

import Data.Maybe
import Data.List
import System.Environment
import System.Argv0
import qualified Filesystem.Path.CurrentOS

type Rules = [Rule]
type Rule = (FileSpec, FileSpec -> IO ())
type File = String
type Targets = [File]
type Deps = [File]
type FileSpec = (Targets, Deps)

-- Generic routine
build' :: String -> String -> Targets -> Rules -> IO ()
build' files_var executable args targets =
  case args  of
    [] -> putStr $ makefile
    prods -> fromJust $ lookup (toKey prods) rules
  where
    toKey prods = list $ sort prods
    
    list = intercalate " "
    allprods = map (fst . fst) targets
    makefile =
      "# -*- makefile -*-\n" ++
      "# Generated by Language.MakeDeps.build\n" ++
      files_var ++ " := " ++ (list $ concat allprods) ++ "\n" ++
      (concat $ map (dep . fst) targets)
    dep (prods, deps) =
      -- FIXME: quoting.  Filenames cannot contain spaces.
      "\n" ++ list prods ++ ": " ++ list (executable:deps) ++ "\n" ++
      "\t" ++ executable ++ " " ++ list prods ++ "\n"

    rules = map (\(pd@(prods, deps), build) -> (toKey prods, build pd)) targets

build :: String -> Rules -> IO ()
build files_var targets = do
  -- Note: use argv[0] instead of getProgName.  This allows the
  -- makefile to be generated with the proper invocation of the
  -- executable.
  argv0 <- getArgv0
  let argv0' = Filesystem.Path.CurrentOS.encodeString argv0
  args  <- getArgs
  build' files_var argv0' args targets
